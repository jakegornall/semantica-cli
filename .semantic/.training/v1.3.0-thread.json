{
  "timestamp": "2024-12-17T19:21:17.927Z",
  "version": "1.3.0",
  "messages": [
    {
      "role": "system",
      "content": "You are a technical documentation expert who creates user-focused documentation for software packages and libraries.\n\nYour task is to analyze the codebase and create two types of documentation chunks:\n\n1. OVERVIEW CHUNK (exactly one):\n   Create a comprehensive overview that explains:\n   - What the package does and its main purpose\n   - How to install and set up the package\n   - Basic configuration requirements\n   - Common use cases and patterns\n   - Getting started guide\n\n2. API CHUNKS (one per public interface):\n   Create individual chunks for each public/exported:\n   - Functions\n   - Components\n   - Classes\n   - Configuration options\n   Only document interfaces that are meant to be used by the end user/consumer of the package.\n\nIGNORE:\n- Internal implementation details\n- Private functions/methods\n- Utility functions not exported\n- Internal classes/components\n\nREQUIRED OUTPUT FORMAT:\n{\n  \"reasoningAndPlanning\": [\n    \"string (reasoning and planning for the chunks)\",\n    \"Make sure to reason over what should and should not be documented\",\n    \"be thorough and consider which files are most relevant to the user\",\n    \"README files are the most relevant to the user\",\n    \"source code that is not exposed as an api to the user is not relevant to the user at all\",\n    \"however, it is important to provide chunks that explain highlevel what the the package is doing under the hood\"\n  ],\n  \"chunks\": [\n    {\n      \"title\": \"string (user-focused topic)\",\n      \"description\": \"string (explanation from user perspective)\",\n      \"examples\": [\n        {\n          \"code\": \"string (example showing how to USE the package)\",\n          \"explanation\": \"string (explanation of the example)\"\n        }\n      ],\n      \"tags\": [\"string\"]\n    }\n  ]\n}\n\nExample of a GOOD overview chunk:\n{\n  \"title\": \"Getting Started with MyPackage\",\n  \"description\": \"MyPackage is a React component library designed for building accessible, performant data visualization components. It provides a comprehensive suite of charts, graphs, and interactive data displays that automatically handle accessibility concerns, responsive design, and complex data updates.\n\nThe library is built with performance in mind, using React's virtual DOM efficiently and implementing smart re-rendering strategies for smooth updates even with large datasets. It supports both TypeScript and JavaScript projects, with full type definitions included.\n\nKey features include:\n- Accessible by default (WCAG 2.1 AA compliant)\n- Responsive and mobile-friendly\n- Support for real-time data updates\n- Comprehensive theming system\n- Built-in animation support\n- Tree-shakeable exports\n- Zero dependencies\n\nThe package is designed to work seamlessly with modern React applications and supports both client-side and server-side rendering (including Next.js and Remix).\",\n  \"examples\": [\n    {\n      \"code\": \"npm install my-package\\n\\nimport { LineChart } from 'my-package';\\n\\nfunction App() {\\n  return (\\n    <LineChart\\n      data={salesData}\\n      xAxis={{ key: 'date', label: 'Sales Period' }}\\n      yAxis={{ key: 'amount', label: 'Revenue' }}\\n      accessibility={{\\n        description: 'Monthly sales data from 2023'\\n      }}\\n    />\\n  );\\n}\",\n      \"explanation\": \"This example shows how to install the package and create a basic line chart with proper accessibility labels and axis configuration\"\n    }\n  ],\n  \"tags\": [\"getting-started\", \"overview\", \"installation\", \"react\", \"data-visualization\"]\n}\n\nExample of a GOOD API chunk:\n{\n  \"title\": \"LineChart Component\",\n  \"description\": \"The LineChart component is a powerful and flexible visualization tool for displaying trend data over time or sequential values. It automatically handles data formatting, scaling, and accessibility requirements while providing extensive customization options.\n\nKey Features:\n1. Automatic Data Scaling:\n   - Smart Y-axis range calculation\n   - Support for different data scales (linear, logarithmic, time)\n   - Custom domain ranges\n\n2. Accessibility:\n   - Automatic ARIA labels and descriptions\n   - Keyboard navigation support\n   - Screen reader optimized data points\n   - High contrast mode support\n\n3. Interactivity:\n   - Hover tooltips with customizable content\n   - Click handlers for data points\n   - Zoom and pan capabilities\n   - Touch device support\n\n4. Responsive Design:\n   - Automatic resizing\n   - Mobile-friendly touch targets\n   - Configurable breakpoints\n   - Optional data point reduction for small screens\n\n5. Performance Optimizations:\n   - Smart data point sampling for large datasets\n   - Efficient re-rendering\n   - Canvas rendering option for heavy workloads\n   - Web Worker support for calculations\n\nThe component accepts both simple arrays and complex nested data structures, with powerful data accessor options for flexible data binding.\",\n  \"examples\": [\n    {\n      \"code\": \"import { LineChart } from 'my-package';\\n\\n<LineChart\\n  data={salesData}\\n  xAxis={{\\n    key: 'date',\\n    label: 'Sales Period',\\n    scale: 'time',\\n    format: (d) => format(d, 'MMM yyyy')\\n  }}\\n  yAxis={{\\n    key: 'amount',\\n    label: 'Revenue',\\n    scale: 'linear',\\n    format: (d) => formatCurrency(d)\\n  }}\\n  tooltip={{\\n    content: (d) => `${d.label}: ${formatCurrency(d.value)}`,\\n    position: 'right'\\n  }}\\n  accessibility={{\\n    description: 'Monthly sales data visualization',\\n    announceDataPoints: true\\n  }}\\n  responsive={{\\n    breakpoints: {\\n      sm: { samplingRate: 0.5 },\\n      lg: { samplingRate: 1 }\\n    }\\n  }}\\n/>\",\n      \"explanation\": \"This example demonstrates a fully configured LineChart with custom formatting, tooltips, accessibility options, and responsive behavior\"\n    }\n  ],\n  \"tags\": [\"components\", \"visualization\", \"charts\", \"line-chart\", \"time-series\"]\n}\n\nRemember: Each chunk should provide comprehensive, user-focused documentation that helps developers understand both basic usage and advanced features.\n\nExample of GOOD reasoningAndPlanning:\n[\n  \"First, I'll analyze the README.md as it's the primary source of user-facing documentation\",\n  \"The package.json reveals this is a React component library for data visualization, so I'll focus on component usage and configuration\",\n  \"I notice there's a /examples directory with working code samples - these will be valuable for creating practical examples\",\n  \"The src/components directory contains exported components, but I'll ignore internal utility functions\",\n  \"The types.ts file defines the public TypeScript interfaces that users need to know about\",\n  \"I'll create an overview chunk first to help users get started quickly\",\n  \"Then I'll create individual API chunks for each exported component\",\n  \"The configuration options in config.ts need their own chunk as they're critical for setup\",\n  \"I'll ignore the internal helper functions in utils/ as they're not part of the public API\",\n  \"The testing files don't need documentation as they're not relevant to package users\",\n  \"I see some advanced usage patterns in the examples that should be documented separately\",\n  \"The migration guide in MIGRATING.md needs its own chunk to help users upgrade versions\"\n]\n\nRemember: Each reasoning step should explain WHY you're including or excluding content based on its relevance to the end user."
    },
    {
      "role": "user",
      "content": "{\n  \"reasoningAndPlanning\": [\n    \"First, I'll analyze the README.md as it's the primary source of user-facing documentation\",\n    \"The package.json reveals this is a CLI tool for generating semantic documentation chunks, so I'll focus on command usage and configuration\",\n    \"The src/index.js file is the entry point and orchestrates the chunk generation process, which is crucial for understanding how to use the package\",\n    \"The bin/semantica.js file defines the CLI commands, which are directly relevant to the user\",\n    \"The src/yamlGenerator.js, src/training.js, and src/aiProvider.js files contain internal logic for generating and syncing chunks, which are not directly exposed to the user\",\n    \"The src/schemas.js file defines schemas for validation, which are important for understanding data structures but not directly used by the user\",\n    \"I'll create an overview chunk to help users get started quickly\",\n    \"Then I'll create individual API chunks for each CLI command exposed in bin/semantica.js\",\n    \"I'll ignore internal helper functions and implementation details as they're not part of the public API\",\n    \"The testing files and internal utility functions don't need documentation as they're not relevant to package users\"\n  ],\n  \"chunks\": [\n    {\n      \"title\": \"Getting Started with Semantica\",\n      \"description\": \"Semantica is a CLI tool designed to generate semantic documentation chunks from your codebase using AI. It leverages GPT-4o to analyze your source code, documentation, and README files, creating user-focused documentation optimized for vector database storage and semantic search.\\n\\nKey features include:\\n- User-focused documentation\\n- Practical examples and common use cases\\n- Clear installation and setup instructions\\n- Semantic search optimization\\n\\nSemantica is ideal for enhancing documentation sites, training AI assistants, powering IDE plugins, and improving search systems.\",\n      \"examples\": [\n        {\n          \"code\": \"npm install -g semantica\\n\\nsemantica chunk\",\n          \"explanation\": \"This example shows how to install Semantica globally and generate semantic chunks from your codebase using the 'chunk' command.\"\n        }\n      ],\n      \"tags\": [\"getting-started\", \"overview\", \"installation\", \"CLI\", \"documentation\"]\n    },\n    {\n      \"title\": \"Chunk Command\",\n      \"description\": \"The 'chunk' command in Semantica is used to generate semantic documentation chunks from your codebase. It scans your project for relevant files, processes them through GPT-4o, and saves the generated chunks in the `.semantic` directory.\\n\\nThis command is essential for keeping your documentation up-to-date and optimized for semantic search.\",\n      \"examples\": [\n        {\n          \"code\": \"semantica chunk\",\n          \"explanation\": \"Running this command will initiate the process of generating semantic documentation chunks from your codebase.\"\n        }\n      ],\n      \"tags\": [\"CLI\", \"command\", \"chunk\", \"documentation\", \"generation\"]\n    },\n    {\n      \"title\": \"Sync Command\",\n      \"description\": \"The 'sync' command in Semantica is used to synchronize approved documentation chunks to the training data. It ensures that your training data is up-to-date with the latest documentation changes, which is crucial for maintaining accurate AI models.\",\n      \"examples\": [\n        {\n          \"code\": \"semantica sync\",\n          \"explanation\": \"This command will sync the approved chunks to the training data, ensuring that your AI models are using the latest documentation.\"\n        }\n      ],\n      \"tags\": [\"CLI\", \"command\", \"sync\", \"training\", \"data\"]\n    }\n  ]\n}"
    }
  ]
}
